#compdef pkg

# zsh completion for pkgng -- https://github.com/pkgng/pkgng

# Heavily based on http://zsh.sf.net/Guide/zshguide06.html#l177

# Martin Geiseler, Mai 2012.

_pkg () {
    local cmd
    if (( CURRENT > 2)); then
		cmd=${words[2]}
		# Set the context for the subcommand.
		curcontext="${curcontext%:*:*}:pkg-$cmd"
		# Narrow the range of words we are looking at to exclude `pkg'
		(( CURRENT-- ))
		shift words
		# Run the completion for the subcommand
		(( $+functions[_pkg_cmd_$cmd] )) && _pkg_cmd_$cmd

    else
		_arguments -s : \
			"-v[Displays the current version of pkg]" \
			"-d[Show debug information]" \
			"-j[pkg will execute in the given jail]:jail:_pkg_listjails" \
			"-c[pkg will chroot in the given Enviroment]:path:_files"
		_values : \
	    	"help[Display usage information of the specified command]" \
	    	"add[Registers a package and installs it on the system]" \
	    	"audit[Reports vulnerable packages]" \
	    	"autoremove[Delete packages which were automatically installed as dependencies and are not required any more]" \
	    	"backup[Dump the local package database to a file specified on the command-line]" \
	    	"check[Sanity checks installed packages]" \
	    	"clean[Cleans the local cache of fetched remote packages]" \
	    	"create[Create a package]" \
	    	"delete[Delete a package from the database and the system]" \
	    	"info[Display information about installed packages]" \
	    	"install[Install a package from a remote package repository]" \
	    	"query[Query information about installed packages]" \
	    	"register[Register a package in the database]" \
	    	"repo[Create a local package repository for a remote usage]" \
	    	"shell[Fires uo a sqlite shell to the local or remote database. Take extreme care]" \
	    	"rquery[Query information for remote repositories]" \
	    	"search[Search for the given pattern in the remote package repositories]" \
	    	"set[Modify information in the installed database]" \
	    	"shlib[Displays which packages link to a specific shared library]" \
	    	"update[Update the available remote repositories]" \
	    	"updating[Display UPDATING entries of installed packages]" \
	    	"upgrade[Upgrade a packae to a newser version]" \
	    	"version[Summarize installed versions of packages]" \
	    	"which[Query the database for package(s) that installed a specific file]"
    fi   
}

_pkg_cmd_help () {
	
}

_pkg_cmd_add () {
	_arguments -s : \
		- somepackage \
			"*:package:_files"
}

_pkg_cmd_audit () {
	_arguments -s : \
		"-F[Fetch the database befor checking]" \
		":package:_pkg_listpkgs"
}

_pkg_cmd_autoremove () {
	_arguments -s : \
		"-y[Assume yes when asked for confirmation before package autoremoval]" \
		"-q[Force quiet output]" 
}

_pkg_cmd_backup () {
	_arguments -s : \
		"-d[Dumps the local package database to a file]:path:_files" \
		"-r[Uses file in order to restore the local package database]:path:_files" 
}

# Not ready
_pkg_cmd_check () {
	_arguments -s : \
		"-d[Check for and install missing dependencies]" \
		"-r[Recompute sizes of installed packages]" \ 
		"-s[Check to find invalid checksums for installed packages]"
}

_pkg_cmd_install () {
	_arguments -s : \
		- somepackage \
			"*:package:_pkg_listports"
}

_pkg_cmd_delete () {
	_arguments -s : \
		"-f[Forces packages to be removed]" \
		"-a[Deletes all installed packages from the system and the database]" \
		"-y[Assume yes when asked for confirmation before package deletion]" \
		"-g[Treat the package names as shell glob patterns]" \
		"-x[Treat the package names as regular expressions]" \
		"-X[Treat the package names as extended regular expressions]" \
		"-q[Force quit output]" \
		- installedpkg \
			"*:package:_pkg_listpkgs"
}


# Helper

_pkg_listpkgs () {
	local ret=1 r
	for r in $(pkg query "%n-%v") ; do
		compadd $r && ret=0
	done
	return ret
}

_pkg_listports () {
  	local ret=1 _fbsd_ports _fbsd_cat
   	_fbsd_cat=(${PORTSDIR:-/usr/ports}/[a-z]*(/:t))
   	if [[ $PREFIX != */* ]] ; then
    	_wanted cat_packages expl 'category/ports' compadd -S '/' $_fbsd_cat
   	else
     	compset -P '*/'
    	_fbsd_ports=(${PORTSDIR:-/usr/ports}/$IPREFIX/*(/:t))
    	_wanted cat_packages expl 'category/ports' compadd $_fbsd_ports
   	fi
  	return ret
}

# rework this to use jls for non ezjail users
_pkg_listjails () {
    local jailcfgs="/usr/local/etc/ezjail"
    local state=$1
    local ret=1
    local j
    # Those names have already been passed through "tr -c '[alnum]' _" by ezjail
    for j in $jailcfgs/*(:t) ; do
	case $state in
	running) [[ -f /var/run/jail_${j}.id ]] && compadd $j && ret=0 ;;
	stopped) [[ -f /var/run/jail_${j}.id ]] || compadd $j && ret=0 ;;
	*)       compadd $j && ret=0 ;;
	esac
    done
    return $ret
}


_pkg "$@"

# -*- mode: shell-script -*-
